import "hashes/sha256/512bit.code" as sha256compression
import "utils/pack/unpack128.code" as unpack128
import "ecc/babyjubjubParams.code" as curveParams
import "ecc/edwardsScalarMult.code" as scalarMult
import "ecc/edwardsAdd.code" as add
import "utils/pack/nonStrictUnpack256.code" as unpack256
import "./curve-points.code" as curvePoints
import "ecc/edwardsCompress.code" as edwardsCompress


def CONCAT128x216x216(field[128] a, field[216] b, field[216] c)->(field[560]):
	return [...a, ...b, ...c]

def CONCAT216x216(field[216] a, field[216] b)->(field[432]):
	return [...a, ...b]

def ORDEREDCONCAT216x216(field order, field[216] f, field[216] g)->(field[432]):
	field[216] r = if order==0 then g else f fi
	field[216] s = if order==0 then f else g fi
	return [...r, ...s]

def shaPad432To512(field[432] a)->(field[512]):
	return [...a, 1, 70....0, 1,1,0,1,1,0,0,0,0]

def shaPad216To512(field[216] a)->(field[512]):
	return [...a, 1, 287....0, 1,1,0,1,1,0,0,0]

def shaPad128To512(field[128] a)->(field[512]):
	return [...a, 1, 375....0, 1,0,0,0,0,0,0,0]

//this function computes a pedersen hash followed by a sha hash for extra safety
def hash(field[128] c, field[2] Pk, field[256] S, field[20] g, field[10] cp)->(field[256]):
	field[256] C = [...[0;128], ...c] //convert the 128 bit currency to 256 bit for scalar multiplication
	field[256] Pkx = unpack256(Pk[0])
	field[256] Pky = unpack256(Pk[1])
	field[2] ped = add(add(scalarMult(C,[g[4],g[5]],cp),scalarMult(Pkx,[g[6],g[7]],cp),cp), add(scalarMult(S,[g[8],g[9]],cp),scalarMult(Pky,[g[10],g[11]],cp),cp),cp)
	field[256] com = edwardsCompress(ped, cp)
	field[512] q = shaPad216To512(com[40..256])
	return sha256compression(q[0..256],q[256..512])


//inputs for main are:
//Alice's original coins are C and D

// C, the amount contained in coin z_C (private)
// SkA Alice's secret key (private)
// Sc the serial number for coin z_C (private)
// c0b-c7b - the Merkle path for C (private)

// D, the amount contained in coin z_d (private)
// Sd the serial number for coin z_d (private)
// d0b-d7b - the Merkle path for D (private)

//Nc the nullifier for C (public)
//Nd the nullifier for D (public)

// Alice's new coins
// E, the amount in coin z_e (private)
// PkB Bob's public key (private)
// Se the serial number for coin E (private)
// Ze the z-coin (commitment) corresponding to E (public)

// F, the amount in coin f_e (private)
// Sf the serial number for coin F (private)
// Zf the z-coin (commitment) corresponding to F (public)

// R - the Merkle root (public)

// y1 one of the master public keys
// y2 the other master public key
// x randomly chosen field element

// Note - We truncate the 256 bit SHA hash down to 216 bits to make it fit better with our sha, which can only handle a single round.

//Each field element passed to main() can be at most 128bits, to make use of unpack128() so 216 bit variables span two fields

def main('field' payTo1...0, field pC, 'field' £pSkA1...0, 'field' £pSc1...0, @[private field c*bh, private field c*bl]0...31, private field pOrderC, 'field' pNc1...0, 'field' pR1...0)->(field1):

//Unpack the inputs of main() to 128 bits. We'll unpack each field to its own 128 bit string for simplicity for now. Later efficiencies could be made by grouping some inputs.

	field[128] C = unpack128(pC)

	field[128] SkA1 = unpack128(pSkA1)
	field[128] SkA0 = unpack128(pSkA0)
	field[256] SkA = [...SkA1, ...SkA0]

	field[128] Sc1 = unpack128(pSc1) //this slightly long-winded approach needed so Zokrates can flatten the expressions
	field[128] Sc0 = unpack128(pSc0)
	field[256] Sc = [...Sc1, ...Sc0]

	{field[128] c*b1 = unpack128(c*bh)}31...0
	{field[128] c*b0 = unpack128(c*bl)}31...0
	{field[256] c*b = [...c*b1, ...c*b0]}31...0

	field[128] Nc1 = unpack128(pNc1)
	field[128] Nc0 = unpack128(pNc0)
	field[256] Nc = [...Nc1, ...Nc0]

	field[128] R1 = unpack128(pR1)
	field[128] R0 = unpack128(pR0)
	field[256] R = [...R1, ...R0]

	field[128] orderC = unpack128(pOrderC)

//*************first we construct a proof that the nullifier Nc is correct************
	//concatenate Sc|Sk. The padding needs to be added to create a true hash

		field[432] t = CONCAT216x216(Sc[40..256], SkA[40..256])
		field[512] u = shaPad432To512(t)
		field[256] nc = sha256compression(u[0..256],u[256..512])

// *********next, calculate Alice's public key from her private key: PkA = g.sha(SkA)
	//first we need some babyjubjub curve information and a few points on the curve (taken from
	//ZoKrates, so there's nothing up our sleeve)
		field[10] cp = curveParams()
		field[20] g = curvePoints()
		field[2] gk = [g[0],g[1]]

    field[2] PkA = scalarMult(SkA, gk, cp) // note PkA is an ec point

//*************Prove that Zc is in the Merkle tree

	// ***First calculate a hash of Zc.
		field[256] s = hash(C, PkA, Sc, g, cp)

		//concat 1st through 31st siblings
		{t = ORDEREDCONCAT216x216(orderC[*], s[40..256], c*b[40..256])
		u = shaPad432To512(t)
		s = sha256compression(u[0..256],u[256..512])}31...1

		// concat with the 32nd sibling. This should equal the root.
		t = ORDEREDCONCAT216x216(orderC[0], s[40..256], c0b[40..256])
		u = shaPad432To512(t)
		field[256] rc = sha256compression(u[0..256],u[256..512])

//*************Need to prove that Pk is in the whitelist**************

  // TODO

//**************Now test the proofs, entwining the payTo variable in the proof

payTo1 * 1 == payTo1
payTo0 * 1 == payTo0
Nc[40..256] == nc[40..256]
R[40..256] == rc[40..256]

C[0] == 0 //overflow prevention
return 1
